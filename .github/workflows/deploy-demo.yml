name: Deploy Demo

on:
  push:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: windmar-nav/windmar

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: docker/setup-buildx-action@v3

      - uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-api:demo
          build-args: "BUILD_COMMIT=${{ github.sha }}"
          no-cache: true

      - uses: docker/build-push-action@v6
        with:
          context: ./frontend
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-frontend:demo
          build-args: "NEXT_PUBLIC_API_URL=${{ secrets.DEMO_API_URL }}\nNEXT_PUBLIC_DEMO_MODE=true"
          cache-from: type=gha
          cache-to: type=gha,mode=max

  deploy:
    needs: build
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch'

    steps:
      - uses: actions/checkout@v4

      - name: Copy files to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEMO_VPS_HOST }}
          username: ${{ secrets.DEMO_VPS_USER }}
          key: ${{ secrets.DEMO_VPS_SSH_KEY }}
          source: "docker-compose.demo.yml,Caddyfile,docker/init-db.sql,data/demo-engine-log-seed.sql,data/demo-snapshot.sql.gz"
          target: /opt/windmar-demo

      - name: Deploy on VPS
        uses: appleboy/ssh-action@v1.0.3
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_ACTOR: ${{ github.actor }}
          ORIGIN_CERT: ${{ secrets.DEMO_ORIGIN_CERT }}
          ORIGIN_KEY: ${{ secrets.DEMO_ORIGIN_KEY }}
        with:
          host: ${{ secrets.DEMO_VPS_HOST }}
          username: ${{ secrets.DEMO_VPS_USER }}
          key: ${{ secrets.DEMO_VPS_SSH_KEY }}
          envs: GH_TOKEN,GH_ACTOR,ORIGIN_CERT,ORIGIN_KEY
          script: |
            cd /opt/windmar-demo
            cat > .env <<'ENVEOF'
            DEMO_DB_PASSWORD=${{ secrets.DEMO_DB_PASSWORD }}
            API_SECRET_KEY=${{ secrets.DEMO_API_SECRET }}
            ENVEOF

            # Bcrypt hashes contain $ which Docker Compose variable
            # substitution would corrupt.  env_file bypasses interpolation.
            cat > .env.hashes <<'HASHEOF'
            DEMO_API_KEY_HASH='${{ secrets.DEMO_API_KEY_HASH }}'
            DEMO_API_KEY_HASHES='${{ secrets.DEMO_API_KEY_HASHES }}'
            FULL_API_KEY_HASHES='${{ secrets.FULL_API_KEY_HASHES }}'
            HASHEOF

            # Write Cloudflare Origin Certificate for TLS
            mkdir -p certs
            echo "${ORIGIN_CERT}" > certs/origin.pem
            echo "${ORIGIN_KEY}" > certs/origin-key.pem
            chmod 600 certs/origin-key.pem

            # Authenticate to GHCR on VPS for pulling private packages
            echo "${GH_TOKEN}" | docker login ghcr.io -u "${GH_ACTOR}" --password-stdin

            docker pull ghcr.io/windmar-nav/windmar-api:demo
            docker pull ghcr.io/windmar-nav/windmar-frontend:demo

            # Ensure data dir and snapshot placeholder exist (prevents Docker dir-mount)
            mkdir -p data
            if [ ! -f data/demo-snapshot.sql.gz ]; then
              echo "-- Empty snapshot placeholder" | gzip > data/demo-snapshot.sql.gz
              echo "WARNING: demo-snapshot.sql.gz was missing, created placeholder"
            fi

            # Force-stop all windmar containers (handles stale state from concurrent runs)
            docker rm -f windmar-db windmar-api windmar-caddy windmar-frontend 2>/dev/null || true

            # Remove only the DB volume (snapshot-seeded, must be fresh each deploy).
            # Keep caddy_data to preserve TLS certs and avoid Let's Encrypt rate limits.
            PGVOL=$(docker volume ls -q | grep postgres_data | head -1)
            [ -n "$PGVOL" ] && docker volume rm "$PGVOL" && echo "Removed DB volume: $PGVOL"

            docker compose -f docker-compose.demo.yml up -d --force-recreate

            # Wait for DB to accept connections
            echo "Waiting for database..."
            for i in $(seq 1 40); do
              if docker exec windmar-db pg_isready -U windmar > /dev/null 2>&1; then
                echo "Database is ready."
                break
              fi
              sleep 5
            done

            # Apply engine log seed via docker cp (avoids stdin pipe issues over SSH)
            if [ -f data/demo-engine-log-seed.sql ]; then
              echo "Copying seed SQL into DB container..."
              docker cp data/demo-engine-log-seed.sql windmar-db:/tmp/seed.sql
              echo "Executing seed SQL..."
              docker exec windmar-db psql -U windmar -d windmar -f /tmp/seed.sql
              echo "Seed exit code: $?"
            else
              echo "WARNING: data/demo-engine-log-seed.sql not found!"
              ls -la data/ || echo "data/ directory does not exist"
            fi

            sleep 10
            docker compose -f docker-compose.demo.yml ps

            # Pre-warm weather caches â€” first request decompresses DB grids (~3-5s).
            # Hitting each endpoint once during deploy means users get instant loads.
            echo "Pre-warming weather caches..."
            API="http://localhost:8003"
            BOUNDS="lat_min=25&lat_max=66&lon_min=-35&lon_max=45"
            for FIELD in wind waves currents ice sst swell visibility; do
              CODE=$(curl -s -o /dev/null -w "%{http_code}" "${API}/api/weather/${FIELD}/frames?${BOUNDS}" || true)
              echo "  ${FIELD}: ${CODE}"
            done
            echo "Cache warming complete."

            docker image prune -f
